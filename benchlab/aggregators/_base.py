from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import StrEnum
from typing import Generic, ClassVar, Any

from benchlab._types import MetricOutputType, InstanceType
from benchlab.utils import get_init_args


class AggregatorType(StrEnum):
    """The enum represents which type of category the aggregator will aggregate."""

    RUNTIMES = "runtimes"

    STATUSES = "statuses"

    METRICS = "metrics"


@dataclass(frozen=True, slots=True)
class Report:
    """Report generated by an aggregation."""

    aggregator_name: str
    """Name of the aggregator used to generate the report."""

    outer_output: float
    """Value of the outer function."""

    inner_output: dict[str, float]
    """Values of the inner functions. Map from instance id to value."""


@dataclass(frozen=True, slots=True)
class Aggregator(ABC, Generic[MetricOutputType]):
    """Base class for all aggregators."""

    name: ClassVar[str]
    """Name of the entity being aggregated."""

    type_: ClassVar[AggregatorType]
    """Type of the entity being aggregated."""

    target: str
    """Target/column of the entity being aggregated."""

    @abstractmethod
    def aggregate(self, instances: list[InstanceType]) -> Report: ...

    @abstractmethod
    def _inner(self, *args, **kwargs) -> Any: ...

    @abstractmethod
    def _outer(self, *args, **kwargs) -> float: ...

    def to_dict(self) -> dict[str, str]:
        return {
            "class_module": self.__class__.__module__,
            "class_name": self.__class__.__name__,
            "args": get_init_args(self),
        }
