from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import StrEnum
from typing import Generic, ClassVar

from benchlab._types import MetricOutputType, InstanceType


class AggregatorType(StrEnum):
    RUNTIME = "runtime"

    STATUS = "status"

    REGRESSION_METRICS = "regression"

    BOOLEAN_METRICS = "boolean"


@dataclass(frozen=True, slots=True)
class Report:
    """Report generated by an aggregation."""

    aggregator_name: str
    """Name of the aggregator used to generate the report."""

    outer_output: float
    """Value of the outer function."""

    inner_output: dict[str, float]
    """Values of the inner functions. Map from instance id to value."""


@dataclass(frozen=True, slots=True)
class Aggregator(ABC, Generic[MetricOutputType]):
    """Base class for all aggregators."""

    name: ClassVar[str]
    """Name of the entity being aggregated."""
    type_: ClassVar[AggregatorType]
    """Type of the entity being aggregated."""

    @abstractmethod
    def aggregate(self, instances: list[InstanceType]) -> Report: ...

    @abstractmethod
    def _inner(self, *args, **kwargs) -> float: ...

    @abstractmethod
    def _outer(self, *args, **kwargs) -> float: ...

    def to_dict(self) -> dict[str, str]:
        return {
            "class_module": self.__class__.__module__,
            "class_name": self.__class__.__name__,
        }
