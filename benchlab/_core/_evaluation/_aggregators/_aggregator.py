from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Generic, ClassVar

import numpy as np
from enum import StrEnum

from benchlab._core._types import MetricOutputType, InstanceType


class AggregatorType(StrEnum):
    RUNTIME = "runtime"

    STATUS = "status"

    REGRESSION_METRICS = "regression"

    BOOLEAN_METRICS = "boolean"


@dataclass(frozen=True, slots=True)
class Report:
    """Report generated by an aggregation."""

    aggregator_name: str
    """Name of the aggregator used to generate the report."""

    outer_output: float
    """Value of the outer function."""

    inner_output: dict[str, float]
    """Values of the inner functions. Map from instance id to value."""


@dataclass(frozen=True, slots=True)
class Aggregator(ABC, Generic[MetricOutputType]):
    """Base class for all aggregators."""

    name: ClassVar[str]
    """Name of the entity being aggregated."""
    type_: ClassVar[AggregatorType]
    """Type of the entity being aggregated."""

    @abstractmethod
    def aggregate(self, instances: list[InstanceType]) -> Report: ...

    @abstractmethod
    def _inner(self, *args, **kwargs) -> float: ...

    @abstractmethod
    def _outer(self, *args, **kwargs) -> float: ...

    def to_dict(self) -> dict[str, str]:
        return {
            "class_module": self.__class__.__module__,
            "class_name": self.__class__.__name__,
        }


@dataclass(frozen=True, slots=True)
class RuntimesAggregator(Aggregator[MetricOutputType]):
    name = "runtime_aggregator"
    type_ = AggregatorType.RUNTIME

    def aggregate(self, instances: list[InstanceType]) -> Report:
        # Step 1: Intra-instance aggregation (Median)
        instance_medians = [
            self._inner(
                [runtime for runtime in instance.runtimes if runtime is not None]
            )
            for instance in instances
        ]

        # Step 2: Inter-instance aggregation (Geometric Mean)
        final_score = self._outer(instance_medians)

        return Report(
            aggregator_name=self.name,
            outer_output=final_score,
            inner_output={
                instance.id: inner_
                for instance, inner_ in zip(instances, instance_medians)
            },
        )

    def _inner(self, runtimes: list[float]) -> float:
        """Computes the median using numpy."""
        return float(np.median(runtimes))

    def _outer(self, medians: list[float]) -> float:
        """Computes the geometric mean using numpy log-space arithmetic."""
        # Note: medians must be positive (> 0) for Geometric Mean
        arr = np.array(medians)
        if np.any(arr <= 0):
            # Fallback or handling for 0.0 runtimes (which shouldn't happen)
            return 0.0

        return float(np.exp(np.log(arr).mean()))


@dataclass(frozen=True, slots=True)
class StatusAggregator(Aggregator[MetricOutputType]):
    name = "status_success_rate_aggregator"
    type_ = AggregatorType.STATUS

    def aggregate(self, instances: list[InstanceType]) -> Report:
        instance_metrics = []
        inner_output: dict[str, float] = {}
        weights: list[int] = []

        for instance in instances:
            # 1. Collect statuses (True for COMPLETED, False otherwise)
            # Assuming run.status is an Enum or String
            success_flags = [
                1 if status == "success" else 0 for status in instance.statuses
            ]

            if not success_flags:
                continue

            instance_success_rate = self._inner(success_flags)
            inner_output[instance.id] = instance_success_rate

            weights.append(len(success_flags))
            instance_metrics.append(instance_success_rate)

        return Report(
            aggregator_name=self.name,
            inner_output=inner_output,
            outer_output=self._outer(success_rates=instance_metrics, weights=weights),
        )

    def _inner(self, statuses: list[int]) -> float:
        """Computes the median success rate for a single instance."""
        if not statuses:
            return 0.0
        return float(np.median(statuses))

    def _outer(self, success_rates: list[float], weights: list[int]) -> float:
        """Computes the weighted arithmetic mean."""
        return float(np.average(success_rates, weights=weights))


# todo: complete here
"""
@dataclass(frozen=True, slots=True)
class MacroAverageAggregator(Aggregator[BooleanOutputType]):
    name: ClassVar[str] = "macro average"
    value: float

    def aggregate(self, instances: list[InstanceType]) -> Report:
        return Report(0, {})

    def _inner(self, data: np.ndarray) -> float:
       
        if data.size == 0:
            return 0.0
        return np.nanmean(data)

    def _outer(self, inner_value: float) -> float:
        return float(inner_value)
"""
