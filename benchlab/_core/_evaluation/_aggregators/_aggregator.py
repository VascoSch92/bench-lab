from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Generic, ClassVar

import numpy as np
from enum import StrEnum

from benchlab._core._types import MetricOutputType, InstanceType


class AggregatorType(StrEnum):
    RUNTIME = "runtime"

    STATUS = "status"

    REGRESSION_METRICS = "regression"

    BOOLEAN_METRICS = "boolean"


@dataclass(frozen=True, slots=True)
class Report:
    """Report generated by an aggregation."""

    aggregator_name: str
    """Name of the aggregator used to generate the report."""

    outer_output: float
    """Value of the outer function."""

    inner_output: dict[str, float]
    """Values of the inner functions. Map from instance id to value."""


@dataclass(frozen=True, slots=True)
class Aggregator(ABC, Generic[MetricOutputType]):
    """Base class for all aggregators."""

    name: ClassVar[str]
    """Name of the entity being aggregated."""
    type_: ClassVar[AggregatorType]
    """Type of the entity being aggregated."""

    @abstractmethod
    def aggregate(self, instances: list[InstanceType]) -> Report: ...

    @abstractmethod
    def _inner(self, *args, **kwargs) -> float: ...

    @abstractmethod
    def _outer(self, *args, **kwargs) -> float: ...


@dataclass(frozen=True, slots=True)
class RuntimesAggregator(Aggregator[MetricOutputType]):
    name = "runtime_aggregator"
    type_ = AggregatorType.RUNTIME

    def aggregate(self, instances: list[InstanceType]) -> Report:
        # Step 1: Intra-instance aggregation (Median)
        instance_medians = [self._inner(inst.runtimes) for inst in instances]

        # Step 2: Inter-instance aggregation (Geometric Mean)
        final_score = self._outer(instance_medians)

        return Report(
            aggregator_name=self.name,
            outer_output=final_score,
            inner_output={
                instance.id: inner_
                for instance, inner_ in zip(instances, instance_medians)
            },
        )

    def _inner(self, runtimes: list[float]) -> float:
        """Computes the median using numpy."""
        return float(np.median(runtimes))

    def _outer(self, medians: list[float]) -> float:
        """Computes the geometric mean using numpy log-space arithmetic."""
        # Note: medians must be positive (> 0) for Geometric Mean
        arr = np.array(medians)
        if np.any(arr <= 0):
            # Fallback or handling for 0.0 runtimes (which shouldn't happen)
            return 0.0

        return float(np.exp(np.log(arr).mean()))


# todo: complete here
"""
@dataclass(frozen=True, slots=True)
class MacroAverageAggregator(Aggregator[BooleanOutputType]):
    name: ClassVar[str] = "macro average"
    value: float

    def aggregate(self, instances: list[InstanceType]) -> Report:
        return Report(0, {})

    def _inner(self, data: np.ndarray) -> float:
       
        if data.size == 0:
            return 0.0
        return np.nanmean(data)

    def _outer(self, inner_value: float) -> float:
        return float(inner_value)
"""
